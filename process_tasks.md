## Задачи по процессам

1. Опишите, что происходит, при выполнении любой команды в консоли, например:
    `$ ls -l` 

***Ответ:***
   Нам дан процесс bash, который ожидает от нас ввод команды. При вводе команды (если это не builtin команда) bash делает системный вызов fork() - 
   создается дочерний процесс bash, который уже вызывает exec() у команды, которую мы ввели. 
   Исходный bash при этом параллельно вызвал wait(), чтобы висеть и ждать когда вызванная команда вернет exit, чтобы вернуть себе управление.


2. Используя ключ 'o', выведите с помощью `ps` список всех процессов в таком формате:
    `PID USER     %CPU    VSZ TT       COMMAND`
    пояснение: ID процесса, пользователь (real user), % загрузки CPU, размер виртуальной памяти, управляющий терминал, команда

    прикрепите вывод к задаче, перенаправив вывод на `head`:

    `$ ps ... ваши опции ... | head` 

***Ответ:***    
`$ ps -e -o pid,ruser=USER,pcpu,vsz,tty=TT,comm | head`
```text

    PID USER     %CPU    VSZ TT       COMMAND
      1 root      0.0  23104 ?        systemd
      2 root      0.0      0 ?        kthreadd
      3 root      0.0      0 ?        pool_workqueue_release
      4 root      0.0      0 ?        kworker/R-rcu_gp
      5 root      0.0      0 ?        kworker/R-sync_wq
      6 root      0.0      0 ?        kworker/R-kvfree_rcu_reclaim
      7 root      0.0      0 ?        kworker/R-slub_flushwq
      8 root      0.0      0 ?        kworker/R-netns
     10 root      0.0      0 ?        kworker/0:0H-events_highpri
```

3. Создайте процесс sleep с помощью 
	    `$ sleep infinity &`
	    
   - найдите его в списке процессов с помощью `ps`. 
   - отфильтруйте вывод `ps` чтобы получить строку только с этим процессом.
   - убейте процесс, отправив ему сигнал '-9' программой `kill`.
     kill 51759
   - убедитесь, что процесса больше нет в списке выдачи `ps`.
     ps -e | grep sleep
     
  ***Ответ:***
  ```text
  $ sleep infinity &
  $ ps -e | grep sleep
     51759 pts/2    00:00:00 sleep
  $ kill -9 51759
  $ ps -e | grep sleep
  ```
